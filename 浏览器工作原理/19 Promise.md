#### 1. `Promise`解决的是什么问题

解决的是异步编码**风格**的问题，而不是其他问题。

#### 2. 异步编程

一个异步编程模型是，页面主线程发起了一个比较耗时的任务，并将任务交给另一个进程去处理，这时页面主线程会继续执行消息队列中的任务，等到进程处理完这个任务，会将该任务添加到渲染进程的消息队列中，等待循环系统的处理。排队结束后，循环系统取出消息队列的任务进行处理，触发相关的回调操作。

异步编程导致了回调地狱。代码看上去很混乱，原因有两点：

+ 嵌套调用
+ 任务的不确定性 每个任务都要进行错误处理

#### 3. `Promise`消灭嵌套调用和多次错误处理

##### 3.1 解决嵌套调用

产生嵌套函数的一个主要原因就是：在发起任务请求时会带上回调函数，这样当任务处理完成后，下个任务就只能在回调函数中处理了。

`promise`通过下面两步解决。

首先是实现了回调函数的延时绑定。回调函数的延迟绑定体现在先创建`Promise`对象`P1`，然后`promise`的构造函数`executor`执行业务逻辑；创建好`Promise`对象`P1`之后，再使用`P1.then`来设置回调函数。

其次，将回调函数`onResolve`的返回值穿透到最外层。

`onResolve`执行完成，有了返回值，如果要根据这个返回值继续异步任务，那么用新的`Promise`包装之后，返回这个新的`Promise`，可以在外部继续用`.then`指定回调函数，形成链式调用。

![img](https://static001.geekbang.org/resource/image/ef/7f/efcc4fcbebe75b4f6e92c89b968b4a7f.png)

##### 3.2 处理异常

多个`Promise`对象链式调用，无论哪个对象抛出错误，都可以通过最后一个对象的`catch`方法捕获，通过这种方式可以将所有的`Promise`对象的错误合并到一个函数来处理，这就解决了每个任务都需要进行错误处理的问题。

之所以可以用最后一个`Promise`对象来处理错误。是因为`Promise`对象的错误具有冒泡的性质，会一直向后传递，直到被`onReject`函数或者`catch`函数捕获，具备了这样的性质，就不需要在每个`Promise`对象中捕获异常了。

