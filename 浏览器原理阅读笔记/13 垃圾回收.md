#### 1. 调用栈中的数据回收

ESP: 记录当前执行状态的指针

当前函数执行完毕，ESP指针下移，下移操作就销毁了当前函数的上下文。

虽然当前函数的上下文仍然保存在栈内存中，但是当新的上下文入栈时，之前上下文占用的内存会被直接覆盖掉，用来存放另一个函数的上下文。

所以，当一个函数执行完毕，js引擎通过向下移动ESP来销毁函数保存在栈中的上下文。

![img](https://static001.geekbang.org/resource/image/b1/3b/b1f0573287b487016334c3f8ec23073b.png)

#### 2. 堆中数据如何回收

回收堆中的数据用的是js中的垃圾回收器。

代际假说：

+ 大部分对象在内存中存在时间很短，也即，很多对象一经分配内存，很快变得不可访问。
+ 不死的对象，一般活得很久

根据对象生存周期的不同使用不同的算法，达到更好的效果。

V8中把堆分为新生代和老生代两个区域。新生代中存放的是生存时间短的对象，老生代中存放的是生存时间长的对象。

新生代：通常只支持1-8M的容量，垃圾回收用的是副垃圾回收器。

老生代：容量较大，垃圾回收用的是主垃圾回收器。

#### 3. 垃圾回收器的工作流程

1. 标记： 标记空间中的活动对象和非活动对象。非活动对象即进行垃圾回收的对象。
2. 回收： 回收非活动对象占用的内存。在所有的标记完成后，统一清理内存中所有被标记为可回收的对象。
3. 内存整理： 一般在频繁的回收对象后，内存中就会存在大量不连续的空间，称为内存碎片。内存中出现大量内存碎片后，如果需要分配较大连续内存的时候，就可能出现内存不足的情况。该步可选，副垃圾回收器不会产生内存碎片。

#### 4. 副垃圾回收器

新生代中采用`Scavenge`算法处理。

`Scavenge`算法： 把新生代空间分为两个部分，一般是对象区域，一般是空闲区域。

新生代中的数据都存放在对象区域，当对象区域快被写满的时候，就需要进行一次垃圾回收。

+ 标记 对对象区域中的垃圾做标记
+ 清理阶段 把存活的对象复制到空闲区域，并且有序连续排布，也相当于完成了内存整理的过程，此时空闲区域无内存碎片
+ 角色替换 复制后，对象区域和空闲区域的角色翻转。这种角色翻转的操作可以让新生代的这两块区域无限重复使用。

`Scavenge`算法需要频繁的复制对象从对象区域到空闲区域，这就导致了时间成本，因此，为了执行效率，新生代的内存一般比较小。

新生代的空间比较小，这也导致了存活对象很容易装满对象区域，，为了解决这个问题，js引擎采用了对象晋升策略。

对象晋升策略：经过了两次垃圾回收依旧存活的对象，会被移动到老生代内存中。

#### 5. 主垃圾回收器

老生代中除了有从新生代晋升的对象，还有一些比较大的对象直接存到老生代。因此，老生代中的对象有两个特点。一是存活时间长，二是对象占用空间大。

正因为老生代中的对象一般比较大。因此使用`Scavenge`算法复制对象效率很低，并且还会浪费一半的时间。

主垃圾回收器采用的是标记-清除（Mark-Sweep）算法。

+ 标记阶段 从一组根元素开始，递归遍历这组根元素，在这个过程中，能到达的元素称为活动对象，没有到达的元素称为垃圾数据。

![img](https://static001.geekbang.org/resource/image/6c/69/6c8361d3e52c1c37a06699ed94652e69.png)

遍历调用栈，1050指向的对象能够到达，1003不能，因此被标记为垃圾数据。

+ 清除阶段 直接清除标记为垃圾数据的对象。

这就是标记-清除算法的过程，不过对一块内存多次进行该过程，会产生大量的内存碎片。

![img](https://static001.geekbang.org/resource/image/d0/85/d015db8ad0df7f0ccb1bdb8e31f96e85.png)

于是产生了另一种算法。标记-整理算法（Mark-Compact）

标记过程与标记-清除算法一致，后续步骤不是对非活动对象的清理，而是让活动对象往内存的一端移动，然后直接清理掉端边界以外的内存。

![img](https://static001.geekbang.org/resource/image/65/8c/652bd2df726d0aa5e67fe8489f39a18c.png)

#### 6. 全停顿

js运行在主线程上，一旦执行垃圾回收算法，需要将正在执行的js脚本暂停，垃圾回收完毕再恢复脚本执行，这种行为叫做全停顿。

为了降低老生代垃圾回收造成的卡顿，v8将标记过程分为一个个的子标记过程，让垃圾回收标记和js应用逻辑交替执行，直到标记阶段完成。这个算法叫做增量标记算法。

