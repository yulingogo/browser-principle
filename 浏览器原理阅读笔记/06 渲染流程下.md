#### 1. 分层

渲染引擎为特定节点生成专用的图层，并生成一棵对应的图层树。

浏览器的页面实际上分成了很多图层，这些图层叠加后合成了最终的页面。

并不是布局树每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

+ 拥有层叠上下文属性的元素会被提升为单独的一层
  + position
  + opacity
  + z-index
  + ...
+ 需要剪裁的地方也会被创建为图层
  + 元素溢出隐藏

#### 2. 图层绘制

渲染引擎把一个图层的绘制拆分成很多小的绘制指令，然后把这些指令按照顺序组成一个待绘制列表。

#### 3. 栅格化操作

待绘制列表值是记录绘制顺序和指令的列表。而实际上绘制操作是由渲染引擎中的合成线程完成的。

也即，当图层的绘制列表完成以后，主线程会把绘制列表提交给合成线程。

视口：通常一个页面很大，但是用户只能看到其中的一部分，我们把用户看到的这一部分叫做视口。

图块：图层可以很大，通过视口，用户只能看到很小一部分，在这种情况下，绘制出所有的涂层内容，就会有很大的开销。所以，合成线程会将图层划分为图块。

合成线程会把视口附近的图块优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是将图块转换成位图。

图块是栅格化的最小执行单位，渲染进程维护了一个栅格化的线程池，所有的图块栅格化都在线程池中执行。

通常，栅格化过程会使用`GPU`来加速生成，使用`GPU`生成位图的过程叫叫做快速栅格化或者`GPU`栅格化，生成的位图保存在`GPU`内存中。这就涉及到了跨进程操作。

 #### 4. 合成和显示

一旦所有图块都被光栅化，合成线程生成一个绘制图块的命令---`DrawQuad`,然后将命令提交给浏览器进程。(原文如此)

浏览器进程有个叫`viz`的组件根据命令将页面内容绘制在内存中，然后再将内存显示在屏幕中。

#### 5. 总结

主线程上的工作

`DOM`---> `style`---> `layout`--->`layer`--->`paint`

非主线程的工作

图层分成图块--->栅格化--->`drawquad`--->`display`

**重排**

从``style``以后全部重新进行，较为耗时

**重绘**

可以跳过`layout`,`layer`

**合成**

跳过layout layer,paint 直接在非主线程上执行合成动画操作，这样的效率是最高的。如`css`的`transfrom`

